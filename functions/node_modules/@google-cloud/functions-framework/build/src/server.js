"use strict";
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.getServer = void 0;
const bodyParser = require("body-parser");
const express = require("express");
const http = require("http");
const onFinished = require("on-finished");
const invoker_1 = require("./invoker");
const pubsub_middleware_1 = require("./pubsub_middleware");
const cloud_event_to_background_event_1 = require("./middleware/cloud_event_to_background_event");
const background_event_to_cloud_event_1 = require("./middleware/background_event_to_cloud_event");
const timeout_1 = require("./middleware/timeout");
const function_wrappers_1 = require("./function_wrappers");
const async_local_storage_1 = require("./async_local_storage");
const execution_context_1 = require("./execution_context");
const logger_1 = require("./logger");
/**
 * Creates and configures an Express application and returns an HTTP server
 * which will run it.
 * @param userFunction - User's function
 * @param options - The configured Function Framework options
 * @return HTTP server
 */
function getServer(userFunction, options) {
    // App to use for function executions.
    const app = express();
    // Express middleware
    // Set request-specific values in the very first middleware.
    app.use('/*', (req, res, next) => {
        (0, invoker_1.setLatestRes)(res);
        res.locals.functionExecutionFinished = false;
        next();
    });
    /**
     * Retains a reference to the raw body buffer to allow access to the raw body
     * for things like request signature validation.  This is used as the "verify"
     * function in body-parser options.
     * @param req - Express request object
     * @param res - Express response object
     * @param buf - Buffer to be saved
     */
    function rawBodySaver(req, res, buf) {
        req.rawBody = buf;
    }
    // Set limit to a value larger than 32MB, which is maximum limit of higher
    // level layers anyway.
    const requestLimit = '1024mb';
    const defaultBodySavingOptions = {
        limit: requestLimit,
        verify: rawBodySaver,
    };
    const cloudEventsBodySavingOptions = {
        type: 'application/cloudevents+json',
        limit: requestLimit,
        verify: rawBodySaver,
    };
    const rawBodySavingOptions = {
        limit: requestLimit,
        verify: rawBodySaver,
        type: '*/*',
    };
    // Use extended query string parsing for URL-encoded bodies.
    const urlEncodedOptions = {
        limit: requestLimit,
        verify: rawBodySaver,
        extended: true,
    };
    // Apply middleware
    if (options.signatureType !== 'typed') {
        // If the function is not typed then JSON parsing can be done automatically, otherwise the
        // functions format must determine deserialization.
        app.use(bodyParser.json(cloudEventsBodySavingOptions));
        app.use(bodyParser.json(defaultBodySavingOptions));
    }
    else {
        const jsonParserOptions = Object.assign({}, defaultBodySavingOptions, {
            type: 'application/json',
        });
        app.use(bodyParser.text(jsonParserOptions));
    }
    app.use(bodyParser.text(defaultBodySavingOptions));
    app.use(bodyParser.urlencoded(urlEncodedOptions));
    // The parser will process ALL content types so MUST come last.
    // Subsequent parsers will be skipped when one is matched.
    app.use(bodyParser.raw(rawBodySavingOptions));
    app.enable('trust proxy'); // To respect X-Forwarded-For header.
    // Disable Express 'x-powered-by' header:
    // http://expressjs.com/en/advanced/best-practice-security.html#at-a-minimum-disable-x-powered-by-header
    app.disable('x-powered-by');
    // Disable Express eTag response header
    app.set('etag', false);
    // Get execution context.
    app.use(execution_context_1.executionContextMiddleware);
    // Store execution context to async local storge.
    app.use(async_local_storage_1.asyncLocalStorageMiddleware);
    if (options.signatureType === 'event' ||
        options.signatureType === 'cloudevent') {
        // If a Pub/Sub subscription is configured to invoke a user's function directly, the request body
        // needs to be marshalled into the structure that wrapEventFunction expects. This unblocks local
        // development with the Pub/Sub emulator
        app.use(pubsub_middleware_1.legacyPubSubEventMiddleware);
    }
    if (options.signatureType === 'event') {
        app.use(cloud_event_to_background_event_1.cloudEventToBackgroundEventMiddleware);
    }
    if (options.signatureType === 'cloudevent') {
        app.use(background_event_to_cloud_event_1.backgroundEventToCloudEventMiddleware);
    }
    if (options.signatureType === 'http') {
        app.use('/favicon.ico|/robots.txt', (req, res) => {
            // Neither crawlers nor browsers attempting to pull the icon find the body
            // contents particularly useful, so we send nothing in the response body.
            res.status(404).send(null);
        });
        app.use('/*', (req, res, next) => {
            onFinished(res, (err, res) => {
                res.locals.functionExecutionFinished = true;
            });
            next();
        });
    }
    app.use((0, timeout_1.timeoutMiddleware)(options.timeoutMilliseconds));
    // Set up the routes for the user's function
    const requestHandler = (0, function_wrappers_1.wrapUserFunction)(userFunction, options.signatureType);
    if (options.signatureType === 'http') {
        app.all('/*', requestHandler);
    }
    else {
        app.post('/*', requestHandler);
    }
    // Error Handler
    if (options.enableExecutionId) {
        app.use(logger_1.errorHandler);
    }
    return http.createServer(app);
}
exports.getServer = getServer;
//# sourceMappingURL=server.js.map