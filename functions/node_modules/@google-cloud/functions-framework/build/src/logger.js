"use strict";
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.getModifiedData = exports.splitArgs = exports.errorHandler = exports.loggingHandlerAddExecutionContext = exports.sendCrashResponse = exports.EXECUTION_CONTEXT_SPAN_ID_KEY = exports.EXECUTION_CONTEXT_TRACE_KEY = exports.EXECUTION_CONTEXT_LABELS_KEY = void 0;
const types_1 = require("./types");
const async_local_storage_1 = require("./async_local_storage");
const buffer_1 = require("buffer");
exports.EXECUTION_CONTEXT_LABELS_KEY = 'logging.googleapis.com/labels';
exports.EXECUTION_CONTEXT_TRACE_KEY = 'logging.googleapis.com/trace';
exports.EXECUTION_CONTEXT_SPAN_ID_KEY = 'logging.googleapis.com/spanId';
const SEVERITY = 'severity';
/**
 * Logs an error message and sends back an error response to the incoming
 * request.
 * @param err - Error to be logged and sent
 * @param res - Express response object
 * @param callback - A function to be called synchronously
 */
function sendCrashResponse({ err, res, callback, silent = false, statusHeader = 'crash', statusOverride = 500, }) {
    if (!silent) {
        console.error(err.stack || err);
    }
    // If user function has already sent response headers, the response with
    // error message cannot be sent. This check is done inside the callback,
    // right before sending the response, to make sure that no concurrent
    // execution sends the response between the check and 'send' call below.
    if (res && !res.headersSent) {
        res.set(types_1.FUNCTION_STATUS_HEADER_FIELD, statusHeader);
        if (process.env.NODE_ENV !== 'production') {
            res.status(statusOverride);
            res.send((err.message || err) + '');
        }
        else {
            res.sendStatus(statusOverride);
        }
    }
    if (callback) {
        callback();
    }
}
exports.sendCrashResponse = sendCrashResponse;
function loggingHandlerAddExecutionContext() {
    interceptStdoutWrite();
    interceptStderrWrite();
}
exports.loggingHandlerAddExecutionContext = loggingHandlerAddExecutionContext;
function interceptStdoutWrite() {
    const originalStdoutWrite = process.stdout.write;
    process.stdout.write = (data, ...args) => {
        const { encoding, cb } = splitArgs(args);
        const modifiedData = getModifiedData(data, encoding);
        return originalStdoutWrite.apply(process.stdout, [modifiedData, cb]);
    };
}
function interceptStderrWrite() {
    const originalStderrWrite = process.stderr.write;
    process.stderr.write = (data, ...args) => {
        const { encoding, cb } = splitArgs(args);
        const modifiedData = getModifiedData(data, encoding, true);
        return originalStderrWrite.apply(process.stderr, [modifiedData, cb]);
    };
}
const errorHandler = (err, req, res, next) => {
    interceptStderrWrite();
    res.status(500);
    res.render('error', { error: err });
};
exports.errorHandler = errorHandler;
function splitArgs(args) {
    let encoding, cb;
    if (args.length > 0 &&
        (buffer_1.Buffer.isEncoding(args[0]) || typeof args[0] === 'undefined')) {
        encoding = args[0];
        args.shift();
    }
    if (args.length > 0 && typeof args[0] === 'function') {
        cb = args[0];
    }
    return { encoding: encoding, cb: cb };
}
exports.splitArgs = splitArgs;
function getModifiedData(data, encoding, stderr = false) {
    const currentContext = (0, async_local_storage_1.getCurrentContext)();
    if (!currentContext) {
        return data;
    }
    const { isJSON, processedData } = processData(data, encoding);
    let dataWithContext;
    if (isJSON) {
        dataWithContext = getJSONWithContext(processedData, currentContext);
        if (stderr && !(SEVERITY in dataWithContext)) {
            dataWithContext[SEVERITY] = 'ERROR';
        }
    }
    else {
        dataWithContext = getTextWithContext(processedData, currentContext);
        if (stderr) {
            dataWithContext[SEVERITY] = 'ERROR';
        }
    }
    return JSON.stringify(dataWithContext) + '\n';
}
exports.getModifiedData = getModifiedData;
function getTextWithContext(data, context) {
    return {
        message: data,
        [exports.EXECUTION_CONTEXT_LABELS_KEY]: { execution_id: context.executionId },
        [exports.EXECUTION_CONTEXT_TRACE_KEY]: context.traceId,
        [exports.EXECUTION_CONTEXT_SPAN_ID_KEY]: context.spanId,
    };
}
function getJSONWithContext(json, context) {
    if (exports.EXECUTION_CONTEXT_LABELS_KEY in json) {
        json[exports.EXECUTION_CONTEXT_LABELS_KEY]['execution_id'] = context.executionId;
    }
    else {
        json[exports.EXECUTION_CONTEXT_LABELS_KEY] = { execution_id: context.executionId };
    }
    return {
        ...json,
        [exports.EXECUTION_CONTEXT_TRACE_KEY]: context.traceId,
        [exports.EXECUTION_CONTEXT_SPAN_ID_KEY]: context.spanId,
    };
}
function processData(data, encoding) {
    let decodedData;
    try {
        if (data instanceof Uint8Array) {
            decodedData = buffer_1.Buffer.from(data.buffer).toString();
        }
        else {
            decodedData = buffer_1.Buffer.from(data, encoding).toString();
        }
    }
    catch (e) {
        // Failed to decode, treat it as simple text.
        return { isJSON: false, processedData: data };
    }
    // strip any leading ANSI color codes from the decoded data
    // to parse colored JSON objects correctly
    decodedData = decodedData.replace(/\x1b[[(?);]{0,2}(;?\d)*./g, '');
    try {
        return { isJSON: true, processedData: JSON.parse(decodedData) };
    }
    catch (e) {
        return { isJSON: false, processedData: decodedData };
    }
}
//# sourceMappingURL=logger.js.map